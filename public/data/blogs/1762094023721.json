{
  "description": "Before we explore Redis specifically, let’s establish what we mean by push and pull replication models.\n\nPull-based replication: Replicas periodically ask the master, “What’s new?” The replica is responsible for fetching updates. Think of it like checking your mailbox; you decide when to check, and you pull out whatever’s there.\n\nRedis uses the push model. When a write command is executed on the master, Redis propagates that command to all connected replicas immediately (or as immediately as the network allows).",
  "readTime": 8,
  "status": "Completed",
  "id": 1762094023721,
  "createdAt": 1762094023166,
  "updatedAt": 1762094023166,
  "title": "Redis Replication Internals",
  "tags": [],
  "slug": "redis-replication-internals-1762094023721",
  "content": {
    "time": 1762094009408,
    "blocks": [
      {
        "id": "XjbC2YS2oI",
        "type": "title",
        "data": {
          "text": "Redis Replication Internals"
        }
      },
      {
        "id": "Yz5-J7doNb",
        "type": "paragraph",
        "data": {
          "text": "One of the most fundamental design decisions in Redis replication is that it’s push-based rather than pull-based. This means the master (or primary) actively sends data to replicas, rather than replicas polling the master for updates."
        }
      },
      {
        "id": "u78KvbXvte",
        "type": "paragraph",
        "data": {
          "text": "But why did Redis make this choice? What are the trade-offs? And how does this affect your production systems? Let’s dive deep into the engineering reasoning behind this decision."
        }
      },
      {
        "id": "F8YX9Qd1iy",
        "type": "header",
        "data": {
          "text": "Push vs. Pull Replication",
          "level": 2
        }
      },
      {
        "id": "mLHimbA-PO",
        "type": "paragraph",
        "data": {
          "text": "Before we explore Redis specifically, let’s establish what we mean by push and pull replication models."
        }
      },
      {
        "id": "k5ftPRSQH0",
        "type": "paragraph",
        "data": {
          "text": "Pull-based replication: Replicas periodically ask the master, “What’s new?” The replica is responsible for fetching updates. Think of it like checking your mailbox; you decide when to check, and you pull out whatever’s there."
        }
      },
      {
        "id": "5fmRYUctAC",
        "type": "paragraph",
        "data": {
          "text": "Redis uses the push model. When a write command is executed on the master, Redis propagates that command to all connected replicas immediately (or as immediately as the network allows)."
        }
      },
      {
        "id": "eSmBRkCGto",
        "type": "header",
        "data": {
          "text": "Redis Replication",
          "level": 2
        }
      },
      {
        "id": "ZkCpO91HJf",
        "type": "paragraph",
        "data": {
          "text": "To understand why push makes sense, we need to understand how Redis replication actually works."
        }
      },
      {
        "id": "1yL_XP4sBw",
        "type": "header",
        "data": {
          "text": "The Replication Protocol",
          "level": 3
        }
      },
      {
        "id": "iI8urYWnPQ",
        "type": "paragraph",
        "data": {
          "text": "When a replica connects to a master, here’s what happens:"
        }
      },
      {
        "id": "ovyDZy2wfA",
        "type": "paragraph",
        "data": {
          "text": "When a replica connects to a master, here’s what happens:"
        }
      },
      {
        "id": "vlMzKYxsBt",
        "type": "list",
        "data": {
          "style": "ordered",
          "meta": {},
          "items": [
            {
              "content": "The replica sends a <code class=\"inline-code\">PSYNC</code>&nbsp;command to the master",
              "meta": {},
              "items": []
            },
            {
              "content": "If this is the first sync or the replica is too far behind, the master performs a full resync:Master creates an RDB snapshot in the backgroundMaster buffers all new writes during snapshot creationMaster sends the RDB file to the replicaMaster sends the buffered writes",
              "meta": {},
              "items": []
            },
            {
              "content": "After the initial sync, the master enters push mode:Every write command executed on the master is immediately sent to all replicasThis happens via the replication backlog bufferReplicas execute these commands in the same order",
              "meta": {},
              "items": []
            }
          ]
        }
      },
      {
        "id": "YP4hT1ufTm",
        "type": "paragraph",
        "data": {
          "text": "This is where the push nature becomes evident. The master doesn’t wait for replicas to ask for updates; it actively streams commands as they happen."
        }
      },
      {
        "id": "PYVSAWUksQ",
        "type": "header",
        "data": {
          "text": "Replication Backlog",
          "level": 3
        }
      },
      {
        "id": "ecTqbCkqwO",
        "type": "paragraph",
        "data": {
          "text": "The replication backlog is a circular buffer that the master maintains. It stores a recent history of write commands (default 1MB, but tunable). This buffer serves two critical purposes:"
        }
      },
      {
        "id": "-yvBoPq1mm",
        "type": "list",
        "data": {
          "style": "ordered",
          "meta": {},
          "items": [
            {
              "content": "If a replica disconnects briefly, it can resume from where it left off",
              "meta": {},
              "items": []
            },
            {
              "content": "Provides a cushion when replicas temporarily fall behind",
              "meta": {},
              "items": []
            }
          ]
        }
      },
      {
        "id": "L5_dczGHZ3",
        "type": "paragraph",
        "data": {
          "text": "The backlog itself is a push-oriented data structure. The master continuously appends to it and pushes offsets to replicas, rather than replicas pulling from specific offsets."
        }
      },
      {
        "id": "lG8F9IViMv",
        "type": "header",
        "data": {
          "text": "Why Push?",
          "level": 2
        }
      },
      {
        "id": "Bf-7RInbsz",
        "type": "paragraph",
        "data": {
          "text": "Now let’s get to the heart of the matter: why did Redis choose push-based replication?"
        }
      },
      {
        "id": "_F9cqZ6GkU",
        "type": "header",
        "data": {
          "text": "Minimizing Replication Lag",
          "level": 3
        }
      },
      {
        "id": "51NSBS53i0",
        "type": "paragraph",
        "data": {
          "text": "The primary driver is latency. Redis is designed for microsecond-level operations. In a pull-based model, you’d have unavoidable replication lag due to:"
        }
      },
      {
        "id": "4THEpvFEl1",
        "type": "list",
        "data": {
          "style": "unordered",
          "meta": {},
          "items": [
            {
              "content": "Polling interval: Replicas would need to wait for the next poll cycle",
              "meta": {},
              "items": []
            },
            {
              "content": "Batching overhead: Multiple writes between polls would bunch up",
              "meta": {},
              "items": []
            },
            {
              "content": "Request-response latency: Each pull requires a round-trip",
              "meta": {},
              "items": []
            }
          ]
        }
      },
      {
        "id": "mzkAY0_tfA",
        "type": "paragraph",
        "data": {
          "text": "With push-based replication, commands propagate to replicas immediately after execution on the master. The only delay is network transmission time. For most use cases, this means replication lag measured in single-digit milliseconds rather than seconds."
        }
      },
      {
        "id": "10QPa_7yr4",
        "type": "paragraph",
        "data": {
          "text": "Imagine you’re using Redis for session storage in a web application with read replicas. A user logs in (writes to the master), then immediately makes another request that hits a replica. With pull-based replication on a 1-second polling interval, there’s a 50% chance (on average) that the replica doesn’t have the session yet. With push-based replication, the session is likely already there."
        }
      }
    ],
    "version": "2.31.0-rc.7"
  }
}