{
  "id": 1756462370539,
  "title": "Its Various Types",
  "summary": "",
  "createdAt": 1756462370120,
  "content": {
    "time": 1756462370119,
    "blocks": [
      {
        "id": "Sc7bIRuPRu",
        "type": "header",
        "data": {
          "text": "Introduction",
          "level": 2
        }
      },
      {
        "id": "XBdHy5i1sG",
        "type": "paragraph",
        "data": {
          "text": "Hashing is a fundamental concept in the realm of computer science, instrumental in optimizing data retrieval and storage processes. At its core, hashing is a technique that converts a range of key values into a range of indexes of an array. By mapping large data sets to smaller, fixed-size values or keys, hashing facilitates efficient data access, regardless of the volume of data."
        }
      },
      {
        "id": "aDYnAAnP98",
        "type": "header",
        "data": {
          "text": "What is Hashing?",
          "level": 2
        }
      },
      {
        "id": "uGiNyQDTkv",
        "type": "paragraph",
        "data": {
          "text": "Hashing involves applying a hash function to input data — often a large, arbitrary size — to produce a fixed-size string of bytes. The output, known as a hash value or hash code, uniquely identifies the input data. Ideally, a hash function should have the following attributes:"
        }
      },
      {
        "id": "Q0toPO57GU",
        "type": "list",
        "data": {
          "style": "ordered",
          "meta": {},
          "items": [
            {
              "content": "Deterministic:&nbsp;The same input should always produce the same output.",
              "meta": {},
              "items": []
            },
            {
              "content": "Fast Computation:&nbsp;The hash function should be capable of returning the hash value quickly.",
              "meta": {},
              "items": []
            },
            {
              "content": "Minimal Collision:&nbsp;Different inputs should produce unique hash values. While collisions — where different inputs produce the same output — can happen, a good hash function minimizes this probability.",
              "meta": {},
              "items": []
            },
            {
              "content": "Uniform Distribution:&nbsp;The hash function should distribute hash values uniformly across the hash table.",
              "meta": {},
              "items": []
            }
          ]
        }
      },
      {
        "id": "wNUbsyLHMO",
        "type": "header",
        "data": {
          "text": "Types of Hashing",
          "level": 2
        }
      },
      {
        "id": "IANcWhOk3F",
        "type": "paragraph",
        "data": {
          "text": "Hashing can be categorized into various types, each designed to tackle specific challenges and applications. Let’s delve into some of the prominent hashing types:"
        }
      },
      {
        "id": "4dy5fISjO2",
        "type": "header",
        "data": {
          "text": "1. Direct Addressing",
          "level": 3
        }
      },
      {
        "id": "Wd_Ygvqxc9",
        "type": "paragraph",
        "data": {
          "text": "Direct addressing is a simple yet efficient form of hashing where the key value directly serves as the index in the array. While fast and straightforward, it’s not memory-efficient for large datasets with sparse key values."
        }
      },
      {
        "id": "Fgjxve-6hZ",
        "type": "paragraph",
        "data": {
          "text": "Here’s the flowchart depicting the process of Direct Addressing in hashing:"
        }
      },
      {
        "id": "v2-ScWrDXT",
        "type": "image",
        "data": {
          "caption": "",
          "withBorder": false,
          "withBackground": false,
          "stretched": false,
          "file": {
            "url": "https://miro.medium.com/v2/resize:fit:1100/format:webp/1*tRsh7mP9QzPhkXnjz-jY_g.png"
          }
        }
      },
      {
        "id": "LlEeIhKuD7",
        "type": "paragraph",
        "data": {
          "text": "Example: Consider a scenario where you have an array of 10 elements, and you want to store integers that also range from 0 to 9. Here, the element value is directly used as the index. For example, if you have the numbers 3, 6, and 8, you would store them in an array A as follows:"
        }
      },
      {
        "id": "LJiWWmnoHQ",
        "type": "paragraph",
        "data": {
          "text": "A[3] = 3"
        }
      },
      {
        "id": "PIhAGfnWdW",
        "type": "paragraph",
        "data": {
          "text": "A[6] = 6"
        }
      },
      {
        "id": "hP_qto2DMT",
        "type": "paragraph",
        "data": {
          "text": "A[8] = 8"
        }
      },
      {
        "id": "Ev1r8BWBBT",
        "type": "paragraph",
        "data": {
          "text": "The array index directly corresponds to the value being stored, making retrieval straightforward."
        }
      },
      {
        "id": "M30fmzA4sy",
        "type": "header",
        "data": {
          "text": "2. Chaining",
          "level": 3
        }
      },
      {
        "id": "AQwZcLzGJY",
        "type": "paragraph",
        "data": {
          "text": "In chaining, each array index points to a linked list of records that share the same hash function value. When a collision occurs — multiple keys hash to the same index — the new key is added to the respective linked list. While chaining handles collisions gracefully, it can lead to increased search time if the linked lists become too long."
        }
      },
      {
        "id": "7O4JR5hmak",
        "type": "paragraph",
        "data": {
          "text": "Here’s the sequence diagram illustrating the process of Chaining in hashing:"
        }
      },
      {
        "id": "DfEAz-r46v",
        "type": "image",
        "data": {
          "caption": "",
          "withBorder": false,
          "withBackground": false,
          "stretched": false,
          "file": {
            "url": "https://miro.medium.com/v2/resize:fit:1100/format:webp/1*EdE4bGTpC-vbel_JQ0dEiw.png"
          }
        }
      },
      {
        "id": "4Zr5Q8EKf7",
        "type": "paragraph",
        "data": {
          "text": "Example: Let’s hash integers to an array of size 10 using the hash function h(x) = x mod 10. If our set contains the numbers 12, 22, and 32, they would all hash to the index 2. We handle the collision by chaining:"
        }
      },
      {
        "id": "fIUpWbY665",
        "type": "paragraph",
        "data": {
          "text": "<code class=\"inline-code\">Index 2: 12 -&gt; 22 -&gt; 32</code>"
        }
      },
      {
        "id": "HKKs88ADZ4",
        "type": "paragraph",
        "data": {
          "text": "Each array index points to a linked list of entries that hash to the same index. If we were to insert another number, say 42, it would also link to this list:"
        }
      },
      {
        "id": "lKX0hZsQW_",
        "type": "paragraph",
        "data": {
          "text": "<code class=\"inline-code\">Index 2: 12 -&gt; 22 -&gt; 32 -&gt; 42</code>"
        }
      },
      {
        "id": "zueE7Frkkk",
        "type": "header",
        "data": {
          "text": "3. Open Addressing",
          "level": 3
        }
      },
      {
        "id": "v-CoyIztoC",
        "type": "paragraph",
        "data": {
          "text": "Open addressing resolves collisions by finding another empty slot within the array using a method such as linear probing, quadratic probing, or double hashing. While open addressing is space-efficient, it can suffer from clustering, where continuous blocks of slots get filled, impacting performance."
        }
      },
      {
        "id": "80bcpjIAP3",
        "type": "paragraph",
        "data": {
          "text": "Here’s the flowchart depicting the process of Open Addressing in hashing:"
        }
      },
      {
        "id": "johnO_MLjr",
        "type": "image",
        "data": {
          "caption": "",
          "withBorder": false,
          "withBackground": false,
          "stretched": false,
          "file": {
            "url": "https://miro.medium.com/v2/resize:fit:1100/format:webp/1*85zu8JFO10DNoyiX-Gs08Q.png"
          }
        }
      },
      {
        "id": "7wJo1xsoq5",
        "type": "paragraph",
        "data": {
          "text": "Example:&nbsp;Consider a hash table of size 10 and a simple hash function h(x) = x mod 10. If you try to insert the values 1, 11, and 21, all would initially hash to index 1. With&nbsp;linear probing for open addressing, you resolve collisions by checking the next available slot:"
        }
      },
      {
        "id": "JOjRFVeZeX",
        "type": "paragraph",
        "data": {
          "text": "Insert 1: A[1] = 1"
        }
      },
      {
        "id": "vFp-fKKi_z",
        "type": "paragraph",
        "data": {
          "text": "Insert 11: Collision at index 1, so insert at A[2] = 11"
        }
      },
      {
        "id": "i8gHSis1NO",
        "type": "paragraph",
        "data": {
          "text": "Insert 21: Collisions at indexes 1 and 2, so insert at A[3] = 21"
        }
      },
      {
        "id": "N98H0Z0SGX",
        "type": "header",
        "data": {
          "text": "4. Perfect Hashing",
          "level": 3
        }
      },
      {
        "id": "1v-kdRQOBF",
        "type": "paragraph",
        "data": {
          "text": "Perfect hashing is a two-level hashing method where there are no collisions at the second level. The goal is to construct a hash function with zero collisions, ideal for static sets where insertions and deletions are infrequent."
        }
      },
      {
        "id": "Utr604PuFT",
        "type": "paragraph",
        "data": {
          "text": "Here’s the flowchart depicting the process of Perfect Hashing:"
        }
      },
      {
        "id": "Wtl-9CPhKL",
        "type": "image",
        "data": {
          "caption": "",
          "withBorder": false,
          "withBackground": false,
          "stretched": false,
          "file": {
            "url": "https://miro.medium.com/v2/resize:fit:640/format:webp/1*JHVcmTtJmcxeD6LgJCGieA.png"
          }
        }
      },
      {
        "id": "eIbnf150GW",
        "type": "paragraph",
        "data": {
          "text": "Example:&nbsp;Imagine a set {6, 8, 13, 27} that we want to store using perfect hashing. In the first level, we use a hash function h(x) = x mod 4, resulting in a potential collision for 8 and 12. To resolve this at the second level, each slot points to a secondary hash table with a size that’s the square of the number of elements hashing into it."
        }
      },
      {
        "id": "W0aG20mv76",
        "type": "paragraph",
        "data": {
          "text": "For instance, for index 0 (for 8 and 12), we create a secondary array of size 4 (2², since two elements hash to index 0). We then find a secondary hash function for each such array that distributes the keys without collisions."
        }
      },
      {
        "id": "wtTEgkgrAa",
        "type": "header",
        "data": {
          "text": "5. Consistent Hashing",
          "level": 3
        }
      },
      {
        "id": "8GiPZmgFM8",
        "type": "paragraph",
        "data": {
          "text": "Consistent hashing is particularly useful in distributed systems to reduce the rehashing requirements when a hash table is resized. It maps data to physical nodes and ensures that only the nodes directly affected by a change are updated, improving system scalability and performance."
        }
      },
      {
        "id": "X96KpRh9jt",
        "type": "paragraph",
        "data": {
          "text": "Here’s the flowchart depicting the process of Consistent Hashing:"
        }
      },
      {
        "id": "2tJpcm47p-",
        "type": "header",
        "data": {
          "text": "6. Cryptographic Hashing",
          "level": 3
        }
      },
      {
        "id": "RhqzxVIdII",
        "type": "paragraph",
        "data": {
          "text": "Used extensively in security applications, cryptographic hashing ensures data integrity and authentication. Functions like SHA-256 and MD5 produce a fixed-size hash that is nearly impossible to reverse-engineer, making it ideal for password storage, data verification, and digital signatures."
        }
      },
      {
        "id": "9NcJ1sdpvI",
        "type": "paragraph",
        "data": {
          "text": "Here’s the flowchart depicting the process of Cryptographic Hashing:"
        }
      }
    ],
    "version": "2.31.0-rc.7"
  },
  "tags": [],
  "description": "Its Various Types"
}