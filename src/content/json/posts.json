[
  {
    "id": 0,
    "slug": "demo",
    "title": "Getting Started with React",
    "author": "Gourango Modak",
    "date": "1970-01-01",
    "tags": [
      "tag@1",
      "tag@2"
    ],
    "category": "frontend, backend",
    "series": "React Basics",
    "seriesOrder": 1,
    "summary": "Provide your content summary",
    "content": "# Hello there"
  },
  {
    "id": 0,
    "slug": "test",
    "title": "No title given",
    "author": "No author given",
    "date": "1970-01-01",
    "tags": [
      "Test",
      "Test2",
      "Test",
      "Test3",
      "Test4",
      "Test25",
      "Test6",
      "Test26",
      "Test7",
      "Test23",
      "Test33",
      "Test23",
      "Test34",
      "Test244",
      "Test442",
      "Test2532",
      "Test3424",
      "Test2234"
    ],
    "category": "general",
    "series": null,
    "seriesOrder": null,
    "summary": "Hello there...",
    "content": "# ü•Ö Goal\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nWrite a function that generates a **globally unique identifier (ID)** each time it is invoked. This ID will be used to uniquely identify **any entity**.\r\n\r\n# üîí Constraints\r\n\r\n-   **ID must be generated on the Application Server**\r\n    -   [[Reason behind - ID must be generated on the Application Server]]\r\n-   **ID must not exceed 64 bits in length**\r\n    -   So it can be stored in a standard integer type, such as `unsigned long int`\r\n\r\n---\r\n\r\n### üß† Example Use Case\r\n\r\nLet‚Äôs say we are building an `ImageUploader` application:\r\n\r\n-   A user uploads an image via the website\r\n-   The application server receives the request\r\n-   The server generates a unique ID for the uploaded image\r\n-   The image metadata (including the ID) is then stored in the database\r\n\r\n![[_assets/ID Generate Strategies - Architecture 1.png]]\r\n\r\n---\r\n\r\n**Let‚Äôs explore some approaches!**\r\n\r\nHere, we‚Äôll look at two ways to generate a unique ID:\r\n\r\n-   üî¢ Using counter variable\r\n-   ‚è∞ Using timestamp\r\n\r\n# üî¢ Using a counter variable\r\n\r\n### üí°Solution #1.1\r\n\r\nGenerate a unique integer using a counter variable.\r\n\r\n```cpp\r\nunsigned long counter = 0;\r\nunsigned long getId()\r\n{\r\n    return counter++;\r\n}\r\n```\r\n\r\nüö© **Issues with this solution**\r\nIf multiple threads execute this function simultaneously, it will cause conflicts (e.g., duplicate IDs).\r\n\r\n### üí°Solution #1.2\r\n\r\nSince multiple threads executing the function simultaneously could cause conflicts, we need to synchronize the critical section to ensure that only one thread can execute it at a time, while others wait until the current thread finishes.\r\n\r\n```cpp\r\nunsigned long counter = 0;\r\nunsigned long getId()\r\n{\r\n    lock(obj)\r\n    {\r\n        counter++;\r\n    }\r\n    return counter;\r\n}\r\n```\r\n\r\nüö© **Issues with this solution**\r\nIf the application or system crashes and restarts, the `counter` variable will reset to zero, potentially causing conflicts.\r\n\r\n### üí°Solution #1.3\r\n\r\nSince the `counter` variable resets to zero when the application or system crashes and restarts, we need to persist its value so that it can resume from where it left off.\r\n\r\n```cpp\r\nunsigned long counter = load();\r\nunsigned long getId()\r\n{\r\n    lock(obj)\r\n    {\r\n        counter++;\r\n        save_counter();\r\n    }\r\n    return counter;\r\n}\r\n```\r\n\r\nüö© **Issues with this solution**\r\nSaving the counter value on each function execution adds some delay, as writing to disk is slower than writing to memory (RAM). Can we improve this?\r\n\r\n### üí°Solution #1.4\r\n\r\nSaving the counter on every function call adds overhead, so we should buffer the operation. For example, instead of saving it each time, we can persist the value every 1,000 executions.\r\n\r\n```cpp\r\nunsigned long counter = load();\r\nunsigned long getId()\r\n{\r\n    lock(obj)\r\n    {\r\n        counter++;\r\n        if (counter % 1000 == 0)\r\n        {\r\n            save_counter();\r\n        }\r\n    }\r\n    return counter;\r\n}\r\n```\r\n\r\nüö© **Issues with this solution**\r\nIf the application or system crashes before the counter is saved, it will restart from the last saved value. For example, if the counter was last saved at 1000 and the crash occurs during the 1999th ID generation, it will restart from 1000 instead of 1999, leading to potential ID conflicts.\r\n\r\n### üí°Solution #1.5 (Final Solution)\r\n\r\nIf a crash occurs before the counter is persisted, the system will fall back to the last saved value. For instance, if the counter was saved at 1000 and the crash happens at ID 1999, the system will restart from 1000, leading to possible ID duplication. To mitigate this, we can apply a buffer when loading the counter‚Äîe.g., resume from saved value + buffer‚Äîto ensure no overlap in case of crashes.\r\n\r\n```cpp\r\nunsigned long counter = load() + 1000;\r\nunsigned long getId()\r\n{\r\n    lock(obj)\r\n    {\r\n        counter++;\r\n        if (counter % 1000 == 0)\r\n        {\r\n            save_counter();\r\n        }\r\n    }\r\n    return counter;\r\n}\r\n```\r\n\r\n#### Why **1000**?\r\n\r\nIf we choose a very large number when preloading the counter, there's a high risk of wasting a large range of IDs in case of an application crash. For example:\r\n\r\n```cpp\r\nunsigned long counter = load() + 1000000;\r\nunsigned long getId()\r\n{\r\n    lock(obj)\r\n    {\r\n        counter++;\r\n        if (counter % 1000000 == 0)\r\n        {\r\n            save_counter();\r\n        }\r\n    }\r\n    return counter;\r\n}\r\n```\r\n\r\nLet‚Äôs say the last saved value was `1,000,000`. Now, right after generating the first new ID (`1,000,001`), the application crashes. Since we save only after every 1,000,000 IDs, the counter was **never persisted again**. After a restart, the system loads `1,000,000` from storage and adds `1,000,000` again ‚Äî jumping to `2,000,000`.\r\n\r\nAs a result, the entire range from `1,000,001` to `1,999,999` (i.e., **999,999 IDs**) is **lost or skipped unnecessarily**.\r\n\r\nThat‚Äôs why we must choose an **optimal preload value** ‚Äî not too small (which would increase I/O overhead from frequent disk writes), and not too large (which increases the risk of wasted IDs).\r\n\r\n### ‚úèÔ∏è Let‚Äôs do a quick back-of-the-envelope calculation\r\n\r\nSince an **unsigned long** is 64 bits, it can generate values from:  \r\n**0 to 18,446,744,073,709,551,615** (‚âà **18.4 quintillion**)\r\n\r\nTo put that into perspective, here‚Äôs how long it would take to overflow if you generate IDs at different speeds:\r\n\r\n-   üöÄ **1 million IDs/second** ‚âà **292,000 years** to overflow\r\n-   ‚ö° **1 billion IDs/second** ‚âà **292 years**\r\n\r\n# ‚è∞ Using timestamp\r\n\r\n**Epoch Time**\r\nIt represents the number of seconds (or milliseconds) that have passed since a fixed point in time, called the Unix Epoch.\r\n\r\n**üìÖ The Unix Epoch**\r\n\r\n-   Defined as: **00:00:00 UTC on January 1, 1970**\r\n-   So, **epoch time = current time ‚àí Jan 1, 1970**\r\n\r\n**For example:**\r\n\r\n-   `0` = Jan 1, 1970\r\n-   `1,000,000` = ~11 days after\r\n-   `1,725,000,000` = Tue, Jul 16, 2024 (in seconds)\r\n\r\n**üîß How to Customize Epoch Time**\r\n\r\nWe might want to define a **custom epoch** ‚Äî for example, starting from Jan 1, 2020, instead of 1970 ‚Äî to reduce the size of the epoch time.\r\n\r\nSuppose we are launching a new application. If we generate IDs using the standard epoch (starting from 1970), all timestamps will be based on the current time since 1970. **As a result, a large range of smaller values (earlier timestamps) will be unused ‚Äî essentially wasted.** By starting from a recent custom epoch (e.g., the app launch date), we can make better use of the available number space.\r\n\r\n**_Since our constraint is to fit the ID within 64 bits, starting from a smaller number allows us to generate more unique IDs without wasting a large portion of the available number space._**\r\n\r\n---\r\n\r\n### üí°Solution #2.1\r\n\r\n`get_epoch_ms()` returns an integer (epoch time) representing the milliseconds elapsed since January 1, 2025 UTC (the Unix epoch).\r\n\r\nFor example, if the current timestamp is **July 19, 2025, 12:00:00 UTC**, `get_epoch_ms()` would return approximately **1,752,926,400,000** milliseconds.\r\n\r\n```cpp\r\nunsigned long getId()\r\n{\r\n    return get_epoch_ms();\r\n}\r\n```\r\n\r\nüö© **Issues with this solution**\r\nIf multiple threads execute this function simultaneously, it will cause conflicts (e.g., duplicate IDs).\r\n\r\n### üí°Solution #2.2\r\n\r\nSince multiple threads executing the function simultaneously could cause conflicts, we need to synchronize the critical section to ensure that only one thread can execute it at a time, while others wait until the current thread finishes.\r\n\r\n```cpp\r\nunsigned long getId()\r\n{\r\n    lock(obj)\r\n    {\r\n        return get_epoch_ms();\r\n    }\r\n}\r\n```\r\n\r\nüö© **Issues with this solution**\r\nWhile synchronization resolves most conflict issues, it's still possible for two threads to get the same value if they execute within the **same millisecond**, since milliseconds aren't precise enough for high-concurrency scenarios.\r\n\r\n### üí°Solution #2.3\r\n\r\nWhile synchronization resolves most conflict issues, it's still possible for two threads to get the same value if they execute within the **same millisecond**, since milliseconds aren't precise enough for high-concurrency scenarios. To mitigate this, we can introduce a counter that increments if multiple threads execute within the same millisecond. By **concatenating** this counter with the epoch time, we can avoid ID conflicts.\r\n\r\n```cpp\r\nType counter = 0;\r\nType lastEpoch = 0;\r\nType getId()\r\n{\r\n    lock(obj)\r\n    {\r\n        Type curEpoch = get_epoch_ms();\r\n        if (curEpoch == lastEpoch)\r\n        {\r\n            counter++;\r\n        }\r\n        lastEpoch = curEpoch;\r\n    }\r\n    return concat(curEpoch, counter);\r\n}\r\n```\r\n\r\nüìå**Note**\r\n\r\n-   `Type` is a user-defined data type.\r\n-   `concat` is a user-defined function that performs bitwise concatenation of `epoch time` and `counter`.\r\n\r\nSince our ID must fit within 64 bits, we can allocate **56 bits** to the epoch time and **8 bits** to the counter for concatenation.\r\n\r\n<div style=\"text-align: center;\">\r\n  <img src=\"https://plus.unsplash.com/premium_photo-1664474619075-644dd191935f?q=80&w=2669&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\" alt=\"Right aligned\" />\r\n</div>\r\n\r\n‚úèÔ∏è Let‚Äôs do a quick back-of-the-envelope calculation\r\n\r\n-   **56 bits** can represent numbers up to about **72,057,594,037,927,936** (72 quadrillion)\r\n-   **8 bits** can represent numbers up to **256**\r\n\r\nTo put that into perspective, here‚Äôs how long it would take to overflow if you generate IDs at different speeds:\r\n\r\n-   üöÄ **1 million IDs/second** ‚Üí ‚âà **2,283 years** to overflow\r\n-   ‚ö° **1 billion IDs/second** ‚Üí still takes ‚âà **2.28 years**\r\n\r\nüö© **Issues with this solution**\r\nSince the counter uses only **8 bits**, it can hold values from `0 to 255`. In high-concurrency scenarios, multiple threads may invoke the function within the same millisecond. Over time, this can cause the counter to **overflow**, resulting in **corrupted values** being combined with the epoch timestamp, potentially leading to **ID collisions** or **invalid IDs**.\r\n\r\n### üí°Solution #2.4\r\n\r\nIn high-concurrency scenarios, multiple threads may invoke the function within the same millisecond. Over time, this can cause the counter to **overflow**. To address this, resetting the counter when the millisecond changes prevents the overflow issue.\r\n\r\n```cpp\r\nType counter = 0;\r\nType lastEpoch = 0;\r\nType getId()\r\n{\r\n    lock(obj)\r\n    {\r\n        Type curEpoch = get_epoch_ms();\r\n        if (curEpoch == lastEpoch)\r\n        {\r\n            counter++;\r\n        }\r\n        else\r\n        {\r\n            counter = 0;\r\n            lastEpoch = curEpoch;\r\n        }\r\n    }\r\n    return concat(curEpoch, counter);\r\n}\r\n```\r\n\r\nüö© **Issues with this solution**\r\nSuppose, a machine with **256 or more threads** executing concurrently, it's possible for multiple threads to call the function within the same millisecond. This would **exceed the counter limit**, potentially causing **ID collisions** or **invalid IDs**.\r\n\r\n### üí°Solution #2.5 (Final Solution)\r\n\r\nIf a machine with **256 or more threads** executing concurrently, it's possible for multiple threads to call the function within the same millisecond. This would **exceed the counter limit**, potentially causing **ID collisions** or **invalid IDs**. To address this, when the counter reaches its maximum value, we should wait until the next millisecond before generating more IDs. By doing this, we can avoid collisions effectively.\r\n\r\n```cpp\r\nType counter = 0;\r\nType lastEpoch = 0;\r\nType getId()\r\n{\r\n    lock(obj)\r\n    {\r\n        Type curEpoch = get_epoch_ms();\r\n        if (curEpoch == lastEpoch)\r\n        {\r\n            counter++;\r\n            if (counter > MAX_COUNTER)\r\n            {\r\n                // Wait for next millisecond to avoid collision\r\n                while ((curEpoch = get_epoch_ms()) <= lastEpoch);\r\n                counter = 0;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            counter = 0;\r\n            lastEpoch = curEpoch;\r\n        }\r\n    }\r\n    return concat(curEpoch, counter);\r\n}\r\n```\r\n\r\n---\r\n\r\nOur two proposed solutions work well when running the application on a single machine or instance. However, they fail to prevent collisions in a multi-instance environment because:\r\n\r\n-   **Approach #1:** If multiple machines start simultaneously, their counters will start to zero, causing ID collisions.\r\n-   **Approach #2:** If multiple machines generate IDs within the same millisecond, duplicate IDs may be produced due to identical timestamps and counters.\r\n\r\n![[_assets/ID Generate Strategies - Architecture 2.png]]\r\n\r\n### üí°Solution #3.1\r\n\r\nWhen multiple machines start simultaneously, their counters will begin at zero, which can lead to ID collisions. To address this, we can introduce a **machine ID** that is unique to each machine. By concatenating the machine ID with the counter, we can avoid collisions.\r\n\r\nSince our ID must fit within **64 bits**, we can allocate **56 bits** to the counter and **8 bits** to the machine ID.\r\n\r\n```cpp\r\nlong counter = load() + 1000;\r\nlong getId()\r\n{\r\n    lock(obj)\r\n    {\r\n        counter++;\r\n        if (counter % 1000 == 0)\r\n        {\r\n            save_counter();\r\n        }\r\n    }\r\n    return concat(counter, machineID);\r\n}\r\n```\r\n\r\nüß© Challenges\r\n\r\n**How do we generate a machine ID that fits within 8 bits?**\r\nOne approach is to assign a random 8-bit number (0‚Äì255) to each instance during creation. This can be done by generating a random number and saving it to a file that persists across restarts.  \r\nHowever, since the range is very limited (only 256 values), **collisions are highly likely** if multiple machines are created.\r\n\r\nüö© **Issues with this solution**\r\nThe **machine ID space is limited to 8 bits**, which allows only **256 unique values**. Since machine IDs are generated randomly without coordination, **the probability of collision is high**, especially if multiple machines are created.\r\n\r\n### üí°Solution #3.2\r\n\r\nThe counter-based approach from **Solution #3.1** is not viable because machine IDs are assigned randomly, which leads to a **high probability of collision**.  \r\nTherefore, we need to revert to the timestamp-based approach from **Solution #2.5**. However, that approach also has a flaw: when **multiple machines generate IDs within the same millisecond**, **duplicate IDs** can occur due to identical timestamps and counters.\r\n\r\nTo address this, we can **introduce a machine ID** that is unique to each machine. By **concatenating the epoch time, machine ID, and counter**, we can effectively avoid collisions.\r\n\r\nSince the ID must fit within **64 bits**, we can allocate:\r\n\r\n-   **44 bits** for the epoch time\r\n-   **12 bits** for the machine ID\r\n-   **8 bits** for the counter\r\n\r\n```cpp\r\nType counter = 0;\r\nType lastEpoch = 0;\r\nType getId()\r\n{\r\n    lock(obj)\r\n    {\r\n        Type curEpoch = get_epoch_ms();\r\n        if (curEpoch == lastEpoch)\r\n        {\r\n            counter++;\r\n            if (counter > MAX_COUNTER)\r\n            {\r\n                // Wait for next millisecond to avoid collision\r\n                while ((curEpoch = get_epoch_ms()) <= lastEpoch);\r\n                counter = 0;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            counter = 0;\r\n            lastEpoch = curEpoch;\r\n        }\r\n    }\r\n    return concat(curEpoch, machineID, counter);\r\n}\r\n```\r\n\r\nüß© Challenges\r\n\r\n**How do we generate a machine ID that fits within 12 bits?**  \r\nOne approach is to assign a random **12-bit number (0‚Äì4095)** to each instance during creation. This can be done by generating a random number and saving it to a local file that persists across restarts.\r\n\r\n> ‚ö†Ô∏è However, since the machine ID space is limited, **collisions can still occur** if many machines are created.\r\n\r\nThat said, the risk of a **full ID collision remains low** because:\r\n\r\n-   Even if two machines share the same machine ID, their **epoch time** will likely differ.\r\n-   Even if the epoch time also matches, the **counter value** helps distinguish between IDs.\r\n\r\nSo, while machine ID collisions are possible, the combined uniqueness of **epoch + machine ID + counter** makes actual ID duplication **extremely unlikely**.\r\n\r\nSince our ID must fit within 64 bits, we can allocate **44 bits** for the epoch time and **12 bits** for the machine ID and **8 bits** for the counter for concatenation.\r\n\r\n```\r\n|------------------------------------------------------------|\r\n|                             64 bits                        |\r\n|------------------------------------------------------------|\r\n|      44 bits       |      12 bits       |      8 bits      |\r\n|--------------------|--------------------|------------------|\r\n|     Epoch Time     |     Machine ID     |      Counter     |\r\n|--------------------|--------------------|------------------|\r\n```\r\n\r\n‚úèÔ∏è Let‚Äôs do a quick back-of-the-envelope calculation:\r\n\r\n-   **44 bits** can represent numbers up to **17,592,186,044,416** (~17.59 trillion)\r\n-   **12 bits** can represent numbers up to **4,096**\r\n-   **8 bits** can represent numbers up to **256**\r\n\r\nTo put that into perspective, here‚Äôs how long it would take to overflow the **44-bit epoch time** field if you generate IDs at different speeds:\r\n\r\n-   üöÄ **1 million IDs/second** ‚Üí 17,592,186 seconds ‚âà **203.6 days**\r\n-   ‚ö° **1 billion IDs/second** ‚Üí 17,592 seconds ‚âà **4.88 hours**"
  }
]